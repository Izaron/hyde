---
layout: post
title: Competitive programming and cyberpunk
language: ru
---

![](https://media.giphy.com/media/NKEt9elQ5cR68/giphy.gif)

_В мире будущего многое изменилось, но алгоритмы все так же популярны_

Я довольно долго занимался спортивным программированием, и не пожалел, что потратил довольно много времени на это дело. Спортивное программирование это круто! Если вы не верите, то позвольте доказать это вам.

<!--break-->

## Спортивное программирование это интересно

На самом деле, если человек серьезно вникает в спортивное программирование, то он учит множество интересных вещей. Структуры данных, теория графов, строковые алгоритмы, а также динамическое программирование, теория игр, комбинаторика... Список довольно большой. 

![](https://static1.squarespace.com/static/543593e4e4b0bf8b316933e3/t/55224459e4b0ab9c8e348de9/1428309084880/firstattempt.jpg)

_А еще поймет, почему этот код тормозит как телефон с Android 2.3.2_

## Спортивное программирование помогает лучше разбираться в коде и прокачивает мозги

![](https://s-media-cache-ak0.pinimg.com/originals/be/82/8c/be828c40bb5a13d25c1e2579514ed6f3.gif)

_Что-то пошло не так, и я не могу с этим справиться уже два часа_

#### Rubber Duck на стероидах

Соревнования по СП имеют жесткое ограничение по времени. Если вы не отдебажили свое решение вовремя, то вы теряете ценное время/баллы/получаете бОльший штраф. Мозг, настроенный на СП, не будет размазывать поиск бага на час, он его найдет за несколько минут. На самом деле многие задания такие комплексные, что ошибку в них можно допустить в десяти местах. Так что скилл дебаггинга сильно прокачивается.

#### Серьезно, вы должны понимать, как это все работает

Огромное количество программистов не имеет понятия, как работает на самом деле std::map/TreeMap и std::set/TreeSet, не говоря о других вещах. Для них это черная магия. Из-за этого они допускают разные нелепости в виде кода, который работает намного медленнее, чем мог бы работать.

![](https://68.media.tumblr.com/001f6b1a313463ac3a0b4cbaf21a98cb/tumblr_nvi1n5aODQ1udwzyuo1_500.gif)

#### А что такое "сдвиг массива"?

Хотя я не буду далеко ходить за примером - допустим, у нас есть std::vector/ArrayList из 100000 элементов. Нужно написать код, который в цикле постоянно просматривает крайний элемент и затем удаляет его. Логично и "удобно" написать код, удаляющий первый элемент. И тут нас ждет сюрприз - оказывается, что этот код будет работать несколько секунд! А если бы мы удаляли всегда последний элемент, это бы отработало практически мгновенно. Опытный программист сразу понимает, почему так происходит. (Хотя, если бы мы использовали double-linked list, это работало бы быстро в обеих случаях).

#### To be continued

Есть и другие побочные эффекты, как появившаяся способность *быстро* писать код, но это все выходит за рамки данного поста.

## Спортивное программирование это престижно      
![](https://static.tumblr.com/0c4c1044875d8d4b73b616699b4f4c37/35ras8e/dfin2bmo6/tumblr_static_bg_cyberjam_night.png)
                                                                                                                                                                                        
СП никогда не было чем-то андерграундным. В мире постоянно проводятся контесты с интересными задачами. Самые известные соревнования это ACM ICPC - олимпиада для студентов, и IOI - для школьников. Также в интернете регулярно проводятся крупные контесты как Google Code Jam, Facebook Hacker Cup, где лучшим участникам оплачивается поездка на "онсайт" - финальный раунд. В России проводятся похожие ежегодные олимпиады VK Cup, Яндекс.Алгоритм, Russian Code Cup (от MailRu). Не говоря уже про регулярные соревнования на сайтах, самые популярные из которых Codeforces и TopCoder. Высокий рейтинг на этих сайтах по итогам участия в кратковременных контестах украшает резюме.                                                   
                                                                                                                                                                                        
Контестов много, и системы в них используются абсолютно разные, но суть одинаковая - надо решать задания.                                                                                                                                                                          
                                                                                                                                                                                        
## Как выглядит типичное задание

![](https://68.media.tumblr.com/6e5bf2cc7f2574aed534af35700ac94e/tumblr_opgyaiBTJo1v63h88o1_500.gif)

#### Легенды и саги

Что такое задача - problem? Мы получаем набор чисел и строк из входного потока или файла, и нам надо написать программу, которая читает эти данные, как-то обрабатывает их и выводит другие данные (ответ) в выходной поток/файл. К задаче прилагается условие, которое называется "легендой". В условии также обычно бывает 1-3 примера входных и выходных данных. Легенда устанавливает модель задачи и условное обозначение входных и выходных данных, то есть она как будто говорит "представьте, что следующие N чисел являются элементами массива A, а следующие M чисел это элементы массива B".                                                                                                                                              

![](http://i.imgur.com/IbQ84iF.gif)

#### Рекомендовано к решению

Когда инженеры Google Code Jam давали лекцию про СП, они разобрали неплохое задание с одного из своих раундов - [Evaluation](https://code.google.com/codejam/contest/6274486/dashboard#s=p2).

Дается набор выражений с присваиваниями. Надо узнать, можно ли так упорядочить строки, чтобы все переменные были бы успешно вычислены?

Например, даются эти строки:

```
a=f(b,c)
b=g()
c=h()
```

Ответ "можно". Вот порядок, в котором каждое выражение корректно:

```
b=g()
c=h()
a=f(b,c)
```

А этот порядок был бы невалидным, так как на момент вычисления `a` переменная `c` является undefined:

```
b=g()
a=f(b,c)
c=h()
```

![](http://i.imgur.com/dbidMbl.gif)

#### Система оценки

В каждом файле до 20 тестов. Если мы сможем найти ответ, когда в каждом тесте до сотни строк (n <= 100), то мы получим 12 баллов. Если строк тысяча (n <= 1000), то получим в сумме 12+15 баллов. Разделение на две группы сделано не зря. Часто бывает так, что решение придумывается недостаточно оптимальное, тогда оно получает только часть баллов. Предполагается, что 12 баллов получит решение за [O(n^3)](https://en.wikipedia.org/wiki/Big_O_notation), а 27 баллов дается за [O(n^2)](https://en.wikipedia.org/wiki/Big_O_notation). Лучше сразу написать решение быстрее. 

#### Hack!

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(int argc, char *argv[]) {
    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        cout << "Case #" << i + 1 << ": ";
        cerr << "Test #" << i + 1 << endl;
        cout << (solve() ? "GOOD" : "BAD") << endl;
    }
}
```

`solve()` будет читать очередной тест и говорить нам ответ.

Лучше сразу написать вспомогательную функцию для "разрезания" строки:

```cpp
vector<string> crop(string& s) {
    vector<string> vec;
    string cur = "";

    for (int i = 0; i < (int) s.size(); i++) {
        if (s[i] < 'a' || s[i] > 'z') {
            // if s[i] is not a lowercase english letter
            if (!cur.empty()) {
                vec.push_back(cur);
                cur = "";
            }
        } else {
            cur.push_back(s[i]);
        }
    }

    return vec;
}
```

#### Теория графов

Как нам вообще решать это? Тут на сцену выходит популярная и легендарная **теория графов**.

![](https://s-media-cache-ak0.pinimg.com/originals/37/71/58/377158fca2b73b083fd0aa4a4f703930.gif)

Просто представим нашу задачу в виде графа! Пусть каждая переменная это **вершина** графа, из которой в каждую зависимую переменную (то есть соотв. вершину) идет направленное **ребро**.

#### Построение модели

Наш пример выглядит так - у нас есть точки-вершины в пространстве `a`, `b`, `c`, и есть две стрелки-рёбра, направленные из `a` в другие вершины. Так же можно представить любой тест. Интуитивно задачу можно решить так - мы будем постоянно просматривать граф и смотреть, есть ли где-нибудь вершина, из которой не исходит **ни одного** ребра. Если такая вершина есть, то ее переменную мы "определяем". Саму вершину из графа и ребра к ней выкидываем, и просматриваем граф заново.

![](http://i.imgur.com/noiejkr.gif)

#### Нахождение ответа

Если у нас еще остались неопределенные переменные, но мы не можем найти никакой вершины, откуда не ведет ни одного ребра, это значит что мы имеем **цикл**, то есть зависимости, которых никак разрешить нельзя, потому что где-то `x` зависит от `y`, `y` зависит от `z`, `z` зависит от `x`, грубо говоря. Значит, для этого теста решения нет. Если мы все переменные определили, то решение есть.

#### Дописываем код

```cpp
bool solve() {
    int n;
    cin >> n;

    vector<string> sources(n);  // source lines
    map<string, int> indexes;   // map of "variable name" -> "index"
    vector< vector<string> > deps_raw(n);   // list of dependencies (as variable string)
    vector< set<int> > deps(n);   // list of dependencies (as indexes)

    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;

        sources[i] = s;

        vector<string> variables = crop(s);
        string name = variables[0];
        indexes[name] = i;

        vector<string> var_names;
        for (int z = 2; z < (int) variables.size(); z++)
            var_names.push_back(variables[z]);
        deps_raw[i] = var_names;
    }

    for (int i = 0; i < n; i++) {
        for (auto dep : deps_raw[i]) {
            if (!indexes.count(dep))
                return false;
        }
    }

    for (int i = 0; i < n; i++) {
        set<int> deps_set;
        for (auto dep : deps_raw[i])
            deps_set.insert(indexes[dep]);
        deps[i] = deps_set;
    }

    // main loop here!
    vector<bool> used(n);
    for (int count = 0; count < n; count++) {
        int v = -1;
        for (int i = 0; i < n; i++) {
            if (used[i])
                continue;
            if (deps[i].empty()) {
                v = i;
                break;
            }
        }
        if (v == -1)
            return false;

        cerr << count << "-th line: " << sources[v] << endl;

        used[v] = true;
        for (int i = 0; i < n; i++) {
            if (!used[i]) {
                if (deps[i].count(v))
                    deps[i].erase(v);
            }
        }
    }

    return true;
}
```

[Полный исходный код](https://gist.github.com/Izaron/43c521e5597550029de928c5fb8f3ef9).

![](https://media.giphy.com/media/IojlRkMFIgZVu/giphy.gif)

Скомпилировать можно в вашей IDE или в консоли `g++ -std=c++11 main.cpp -o main`, смотреть работу программы `./main <input_file >output_file`.

Выхлоп в консоли из примера на странице с задачей:

```
Test #1
0-th line: b=g()
1-th line: c=h()
2-th line: a=f(b,c)
Test #2
Test #3
Test #4
0-th line: x=f()
1-th line: y=g(x,x)
```

![](http://4.bp.blogspot.com/-3pgg2B2VrG0/U7ndQIaSTPI/AAAAAAAAAIM/jU3yDsl_wDk/s1600/title.gif)

На этом все, спасибо за внимание! Но не пропадайте надолго...

:wq
